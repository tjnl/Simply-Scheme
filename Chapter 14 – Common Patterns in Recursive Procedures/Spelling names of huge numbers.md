### 14.0 Spelling Names of Huge Numbers

Write a procedure `number-name` that takes a positive integer argument and returns a sentence containing that number spelled out in words:

~~~ scheme
> (number-name 5513345)
(five million five hundred thirteen thousand three hundred forty five)

> (number-name (factorial 20))
(two quintillion four hundred thirty two quadrillion nine hundred two trillion eight billion one hundred seventy six million six hundred forty thousand)
~~~

There are some special cases you will need to consider:

* Numbers in which some particular digit is zero.
* Numbers like 1,000,529 in which an entire group of three digits is zero.
* Numbers in the teens.

Here are two hints. First, split the number into groups of three digits, going from right to left. Also, use the sentence

~~~ scheme
'(thousand million billion trillion quadrillion quintillion
  sextillion septillion octillion nonillion decillion)
~~~

You can write this bottom-up or top-down. To work bottom-up, pick a subtask and get that working before you tackle the overall structure of the problem. For example, write a procedure that returns the word `fifteen` given the argument `15`.

To work top-down, start by writing `number-name`, freely assuming the existence of whatever helper procedures you like. You can begin debugging by writing stub procedures that fit into the overall program but don't really do their job correctly. For example, as an intermediate stage you might end up with a program that works like this:

~~~ scheme
> (number-name 1428425)                      ;; intermediate version
(1 million 428 thousand 425)
~~~

***

The problem is solved using three helper procdures:

* `numbers-to-sentence`, which takes a number and returns it as a sentence of (up to) three-digit words
* `small-number-helper`, which takes a three-, two-, or single-digit number, and spells it out in words
* `large-number-helper`, which takes a sentence of (up to) three digit numbers generated by `numbers-to-sentence`, and spells out the sentence of numbers in words using `small-number-helper`.

~~~ scheme
(define (number-name n)
  (if (= n 0)
      'zero
      (large-number-helper (numbers-to-sentence n '() 0) large-numbers)))

(define large-numbers '(thousand million billion trillion quadrillion quintillion sextillion septillion octillion nonillion decillion))
~~~

#### The “numbers-to-sentence” procedure

~~~ scheme
(define (numbers-to-sentence input-no output-sent counter)
  (cond ((empty? input-no) output-sent)
        ((empty? output-sent) (numbers-to-sentence (bl input-no) (se (last input-no)) 1))
        ((not (= counter 3)) (numbers-to-sentence (bl input-no) (se (word (last input-no) (first output-sent)) (bf output-sent)) (+ 1 counter)))
        (else (numbers-to-sentence (bl input-no) (se (last input-no) output-sent) 1))))
~~~

This recursive procedure takes as its arguments a number `input-no`, an (initially empty) sentence `output-sent`, and a number `counter`.

The base case is that `input-no` is empty, in which case `output-sent` is returned. 

If `output-sent` is empty (which it ought to be the first time the procedure is invoked), the procedure is invoked again with the last digit of `input-no` added to the sentence, and the counter set to `1`.

If the counter hasn’t reached `3` (i.e. we haven’t yet made a 3-digit word), the procedure is invoked again with last digit of `input-no` added to the beginning of the first word in `output-sent`, and the counter increased by `1`.

Otherwise, the counter must have reached `3` (so we are ready to begin making the next 3-digit word), and the procedure is invoked again with the last digit of `input-no` added as a new word to the beginning of `output-sent`, and the counter reset to `1`.

#### The “small-number-helper” procedure

~~~ scheme
(define (small-number-helper n)
  (cond ((and (= (count n) 3) ;; 100–999
              (> (first n) 0))        
         (se (small-number-helper (first n)) 'hundred (small-number-helper (bf n))))
        ((> n 19)             ;; 20–99
         (se (item (- (last (bl n)) 1) '(twenty thirty forty fifty sixty seventy eighty ninety)) (small-number-helper (last n))))
        ((> n 9)              ;; 10–19
         (item (+ (last n) 1) '(ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen)))
        ((> n 0)              ;; 1–9
         (item n '(one two three four five six seven eight nine)))
        (else '())))          ;; 0
~~~

This recursive procedure takes as argument a three-, two-, or single-digit number `n`.

The base cases are:

* `n` is `0`, in which case `'()` is returned (this is so that when recursively invoked with the `00` of `100`, we end up with `(one hundred)` rather than `(one hundred zero)`)
* `n` is less than `10`, in which case the corresponding word from `one` to `ten` is returned
* `n` is less than `20`, in which case the corresponding word from `ten` to `nineteen` is returned.

If `n` is a three-digit number, the procedure returns a sentence comprising:

* the result of recursively invoking the procedure with the first digit of `n`
* the word `hundred`
* the result of recursively invoking the procedure with the final two digits of `n`.

Otherwise `n` must be a two-digit number, so the procedure returns a sentence comprising:

* the word from `twenty` to `ninety` corresponding to the first digit
* the result of recursively invoking the procedure with the last digit. 

(Note that in the latter case, the reason for specifiying the `item` number as `(last (bl n))` rather than `(first n)` is to handle numbers that begin with a `0`, such as the `"090"` in `1090`, because `numbers-to-sentence` encloses these numbers in quotes.)

#### The “large-number-helper” procedure

~~~ scheme
(define (large-number-helper n large-numbers)
  (cond ((empty? n) '())
        ((= (count n) 1) (small-number-helper (first n)))
        (else (let ((y (last (bl n)))
                    (z (last n)))
                (cond ((and (= y 0) (= z 0)) (large-number-helper (bl n) (bf large-numbers))) ;; 0 0
                      ((and (> y 0) (= z 0)) (se (large-number-helper (bl n) (bf large-numbers)) (first large-numbers))) ;; 1 0
                      ((and (> y 0) (> z 0)) (se (large-number-helper (bl n) (bf large-numbers)) (first large-numbers) (small-number-helper z))) ;; 1 1
                      (else (se (large-number-helper (bl n) (bf large-numbers)) (small-number-helper z)))))))) ;; 0 1
~~~

This recursive procedure takes as arguments a sentence of (up to) 3-digit numbers `n` and a previously defined sentence `large-numbers` of units `'thousand`, `'million` etc.

The base cases are:

* `n` is empty, in which case `'()` is returned
* `n` comprises a single (up to) 3-digit number, in which case `small-number-helper` is invoked with that number.

For the convenience of the recursive cases, the last two numbers in the sentence are `let` be `y` and `z` respectively.

Then these last two numbers are analysed, and the result of this analysis determines the treatment of `z`, with the procedure then called recursively with the `butlast` of `n` and the `butfirst` of `large-numbers`.

* if both `y`and `z` are `000`, there is nothing to return – we are still working our way towards a number with the suffix `million` or greater
* if `y` is some number and `z` is `000`, then the current suffix (the `first` of `large-numbers`) is returned; on the next invocation it will be prefixed with the spelled-out `y`
* if both `y` and `z` are not `000`, then the current suffix is returned (to be prefixed by a spelled-out `y` on the next invocation), followed by a spelled-out `z`
* otherwise `y` must be `000` and `z` must be a number,  so `z` is spelled out.

***

#### Second attempt

There is a more idiomatic way of writing `numbers-to-sentence`.

~~~ scheme
(define (numbers-to-sentence n)
  (if (word? n)
      (numbers-to-sentence (se n))
      (let ((first-n (first n)))
        (if (< (count first-n) 3)
            n
            (numbers-to-sentence (se (bl (bl (bl first-n)))
                                    (word (last (bl (bl first-n)))
                                          (last (bl first-n))
                                          (last first-n))
                                    (bf n)))))))
~~~

This takes a number `n` as argument, and returns a sentence of (up to) 3-digit numbers.

Initially, the argument is checked to make sure it is the appropriate type – if `n` is a word (i.e. a number rather than the sentence of numbers that we want it to return), the procedure is invoked with the argument `(se n)`

Otherwise, the base case is where the first word in the argument sentence is 3 digits or less, in which case our sentence `n` must comprise only words of (up to) 3 digits.

If the first word is more than 3 digits, the procedure is recursively invoked with a sentence comprising:

* the first word (number) of `n`, minus its last 3 numbers
* a word made up of those last 3 numbers of `n`
* the `butfirst` of `n`.